<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SQL on itkq.jp</title><link>https://itkq.jp/tags/sql/</link><description>Recent content in SQL on itkq.jp</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Wed, 15 Mar 2017 19:19:27 +0900</lastBuildDate><atom:link href="https://itkq.jp/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>SQL実践入門 読んだ</title><link>https://itkq.jp/blog/2017/03/15/sql-practice/</link><pubDate>Wed, 15 Mar 2017 19:19:27 +0900</pubDate><guid>https://itkq.jp/blog/2017/03/15/sql-practice/</guid><description>&lt;p>メモです．&lt;/p>
&lt;h1 id="3章-式の条件分岐">3章 式の条件分岐&lt;/h1>
&lt;ul>
&lt;li>SQLのパフォーマンスは，テーブルスキャンによる I/O を減らすことが重要．&lt;/li>
&lt;li>手続き的な &lt;code>WHERE&lt;/code>, &lt;code>UNION&lt;/code> による条件分岐，テーブルフルスキャンが複数回行われる．&lt;strong>同テーブル内&lt;/strong>では，&lt;code>SELECT&lt;/code> 句で &lt;code>CASE WHEN&lt;/code> で条件分岐させるとクエリの可読性，実行計画共に良くなることあるので，考えなしに &lt;code>UNION&lt;/code> を使うのは危険．&lt;/li>
&lt;li>ただし，インデックスが使える場合は，「&lt;code>UNION&lt;/code> による複数回のインデックススキャン」と「&lt;code>OR&lt;/code> または &lt;code>IN&lt;/code> による1回のフルスキャン」の勝負になり，&lt;code>UNION&lt;/code> の方が速い場合もある．&lt;/li>
&lt;/ul></description></item><item><title>SQLアンチパターン 読んだ</title><link>https://itkq.jp/blog/2017/01/01/sql-antipattern/</link><pubDate>Sun, 01 Jan 2017 12:38:21 +0900</pubDate><guid>https://itkq.jp/blog/2017/01/01/sql-antipattern/</guid><description>&lt;p>インターネットに読めと言われている気がしたので読んだ。&lt;/p></description></item></channel></rss>
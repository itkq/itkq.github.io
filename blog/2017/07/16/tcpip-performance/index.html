<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content=itkq><meta name=description content="この文章は、ハイパフォーマンスブラウザネットワーキングを読んで、改めて TCP/IP を自分の中で整理し、パフォーマンスに関する内容を簡単にまとめたものである。 情報通信ネットワーク特論を受講しておりタイミングが良かったという理由もある。
IP IP は、パケット交換によるデータ通信網を実現するためのプロトコルである。The Internet ができる前は、Hop-by-Hop（中間ノード間）で信頼性を確保していた。TCP/IP は、経路到達性と信頼性を IP と TCP の形で分離したプロトコルスイートである。この分離により、複雑なトランスポート機能はエンドシステムだけで行えるようになった。このような設計思想は End-to-End Principle と呼ばれる。
TCP TCP は コネクション指向であり、Go-back-N ARQ を基本とする輻輳制御プロトコルである。 コネクション指向通信とは、実際にデータをやりとりする前に、通信を確立する通信である。TCP では、three-way handshake を用いてコネクションを確立する。 シーケンス番号と確認応答番号やチェックサムを使った高品質な伝送のための再送制御は、データ通信網においては必須の機能と言え、TCP の本質的な部分ではない。TCP の本質的に重要な役割は、フロー制御と輻輳制御である。 TCP は、ウィンドウによって上記2つを同時に達成している。
フロー制御 フロー制御は、受信側が処理できるペースで送信するエンドツーエンドのメカニズムである。TCP では、スライディングウィンドウでフロー制御を行う。受信側は送信側に受信ウィンドウサイズ (rwnd) を広告する。通信中は動的にウィンドウサイズを変更できる。
輻輳制御 IP では、データをパケットの単位で交換する。パケット網での輻輳とは、ネットワーク上のパケット量が許容値を超えて、パケットが正常に配送されなかったり、遅延する現象のことである。パケット交換は、実際にはルータが行う。ルータはパケット処理のために多少のバッファがある。パケット過多の場合、バッファにはパケットが累積し、これが遅延となる。また、バッファが一杯の場合、パケットは破棄される。慢性的に輻輳し、エンド間ではパケットを再送する処理をした場合、更に輻輳が悪化する。この現象は輻輳崩壊と呼ばれる。輻輳を防ぐ、または回避するためのメカニズムが輻輳制御である。TCP ではパケットロスを輻輳検知に利用して、輻輳を回避する制御を行う。
スロースタート フロー制御だけでは、ネットワーク自体の許容量を制御できず、輻輳が起こる。通信中に、ネットワークの利用可能な帯域幅に調整する必要がある。利用可能な通信容量を推測する唯一の方法は、実際に送受信をすることである。 TCP 接続毎に輻輳ウィンドウサイズ (cwnd) を初期化し、控えめな値からスタートする。
輻輳制御アルゴリズム スロースタート後は、ACK が帰ってくるたびにウィンドウサイズを大きくする。実際に使用されるウィンドウサイズは、min(rwnd, cwnd) である。TCP では、ウインドウサイズを指数的に増加させる。どこかのタイミングでパケットロスが発生した場合、cwnd を引き下げることで、パケットロスを最小化させる。このときに動作するウインドウサイズを調整するアルゴリズムはいくつかあり、オリジナルは TCP Reno、Linux のデフォルトは TCP CUBIC である。
TCP のパフォーマンス 主に Web ブラウジングのために考慮すべきパフォーマンス事項と Linux での設定。
ウインドウサイズ スロースタート (initcwnd) の緩和  RFC 793: 1 セグメント (MSS; Ethernet だと 1500 Byte) RFC 2581: 最高 4 セグメント RFC 6928: 最高 10 セグメント (Linux 3."><meta name=google-site-verification content=AyWEWMfqdOijgoPW5yMy188xoQqY46L6pFXyd3Jizyc><meta property=og:title content="TCP/IP とパフォーマンス"><meta property=og:description content="この文章は、ハイパフォーマンスブラウザネットワーキングを読んで、改めて TCP/IP を自分の中で整理し、パフォーマンスに関する内容を簡単にまとめたものである。 情報通信ネットワーク特論を受講しておりタイミングが良かったという理由もある。
IP IP は、パケット交換によるデータ通信網を実現するためのプロトコルである。The Internet ができる前は、Hop-by-Hop（中間ノード間）で信頼性を確保していた。TCP/IP は、経路到達性と信頼性を IP と TCP の形で分離したプロトコルスイートである。この分離により、複雑なトランスポート機能はエンドシステムだけで行えるようになった。このような設計思想は End-to-End Principle と呼ばれる。
TCP TCP は コネクション指向であり、Go-back-N ARQ を基本とする輻輳制御プロトコルである。 コネクション指向通信とは、実際にデータをやりとりする前に、通信を確立する通信である。TCP では、three-way handshake を用いてコネクションを確立する。 シーケンス番号と確認応答番号やチェックサムを使った高品質な伝送のための再送制御は、データ通信網においては必須の機能と言え、TCP の本質的な部分ではない。TCP の本質的に重要な役割は、フロー制御と輻輳制御である。 TCP は、ウィンドウによって上記2つを同時に達成している。
フロー制御 フロー制御は、受信側が処理できるペースで送信するエンドツーエンドのメカニズムである。TCP では、スライディングウィンドウでフロー制御を行う。受信側は送信側に受信ウィンドウサイズ (rwnd) を広告する。通信中は動的にウィンドウサイズを変更できる。
輻輳制御 IP では、データをパケットの単位で交換する。パケット網での輻輳とは、ネットワーク上のパケット量が許容値を超えて、パケットが正常に配送されなかったり、遅延する現象のことである。パケット交換は、実際にはルータが行う。ルータはパケット処理のために多少のバッファがある。パケット過多の場合、バッファにはパケットが累積し、これが遅延となる。また、バッファが一杯の場合、パケットは破棄される。慢性的に輻輳し、エンド間ではパケットを再送する処理をした場合、更に輻輳が悪化する。この現象は輻輳崩壊と呼ばれる。輻輳を防ぐ、または回避するためのメカニズムが輻輳制御である。TCP ではパケットロスを輻輳検知に利用して、輻輳を回避する制御を行う。
スロースタート フロー制御だけでは、ネットワーク自体の許容量を制御できず、輻輳が起こる。通信中に、ネットワークの利用可能な帯域幅に調整する必要がある。利用可能な通信容量を推測する唯一の方法は、実際に送受信をすることである。 TCP 接続毎に輻輳ウィンドウサイズ (cwnd) を初期化し、控えめな値からスタートする。
輻輳制御アルゴリズム スロースタート後は、ACK が帰ってくるたびにウィンドウサイズを大きくする。実際に使用されるウィンドウサイズは、min(rwnd, cwnd) である。TCP では、ウインドウサイズを指数的に増加させる。どこかのタイミングでパケットロスが発生した場合、cwnd を引き下げることで、パケットロスを最小化させる。このときに動作するウインドウサイズを調整するアルゴリズムはいくつかあり、オリジナルは TCP Reno、Linux のデフォルトは TCP CUBIC である。
TCP のパフォーマンス 主に Web ブラウジングのために考慮すべきパフォーマンス事項と Linux での設定。
ウインドウサイズ スロースタート (initcwnd) の緩和  RFC 793: 1 セグメント (MSS; Ethernet だと 1500 Byte) RFC 2581: 最高 4 セグメント RFC 6928: 最高 10 セグメント (Linux 3."><meta property=og:type content=article><meta property=og:url content=https://itkq.jp/blog/2017/07/16/tcpip-performance/><meta property=article:published_time content=2017-07-16T19:44:55&#43;09:00><meta property=article:modified_time content=2017-07-16T19:44:55&#43;09:00><title>TCP/IP とパフォーマンス</title><link rel=canonical href=https://itkq.jp/blog/2017/07/16/tcpip-performance/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/github.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500"><link rel=stylesheet href="https://itkq.jp/css/reset.css?t=2020-06-20%2014%3a17%3a11.06095282%20%2b0900%20JST%20m%3d%2b0.094307206"><link rel=stylesheet href="https://itkq.jp/css/pygments.css?t=2020-06-20%2014%3a17%3a11.06095282%20%2b0900%20JST%20m%3d%2b0.094307206"><link rel=stylesheet href="https://itkq.jp/css/main.css?t=2020-06-20%2014%3a17%3a11.06095282%20%2b0900%20JST%20m%3d%2b0.094307206"><link rel=stylesheet href="https://itkq.jp/css/override.css?t=2020-06-20%2014%3a17%3a11.06095282%20%2b0900%20JST%20m%3d%2b0.094307206"><link rel="shortcut icon" href=https://itkq.jp/img/leaf.ico></head><body lang=ja><section class=header><div class=container><a href=https://itkq.jp/><img class=avatar src=https://itkq.jp/img/profile.png srcset="https://itkq.jp/img/profile.png 1x"></a><div class=content><a href=https://itkq.jp/><div class=name>itkq</div></a><nav><ul><li class=nav-blog><a href=https://itkq.jp/blog/><span>Blog</span></a></li><li class=nav-about><a href=https://itkq.jp/about/><span>About</span></a></li></ul></nav></div></div></section><section class=icons><div class=container><div class=content><a href=https://github.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/github.svg alt=github></a>
<a href=https://twitter.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/twitter.svg alt=twitter></a>
<a href=//linkedin.com/in/takuya-kosugiyama-107402195/ target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/linkedin.svg alt=linkedin></a>
<a href=mailto:re@itkq.jp><img class=icon src=https://itkq.jp/img/email.svg alt=email></a></div></div></section><section class="main post non-narrow zero-top-spacing"><div class=container><div class=content><div class=front-matter><div class=title-container><div class=page-heading>TCP/IP とパフォーマンス</div><div class=initials><a href=https://itkq.jp/>ad</a></div></div><div class=meta><div class=date title="Sun Jul 16 2017 19:44:55 JST">Jul 16, 2017</div></div></div><div class=markdown><p>この文章は、ハイパフォーマンスブラウザネットワーキングを読んで、改めて TCP/IP を自分の中で整理し、パフォーマンスに関する内容を簡単にまとめたものである。
<a href="http://www.ocw.titech.ac.jp/index.php?module=General&amp;action=T0300&amp;GakubuCD=2&amp;GakkaCD=321818&amp;KeiCD=18&amp;course=18&amp;KougiCD=201604718&amp;Nendo=2016&amp;lang=JA&amp;vid=03">情報通信ネットワーク特論</a>を受講しておりタイミングが良かったという理由もある。</p><h1 id=ip>IP</h1><p>IP は、パケット交換によるデータ通信網を実現するためのプロトコルである。The Internet ができる前は、Hop-by-Hop（中間ノード間）で信頼性を確保していた。TCP/IP は、経路到達性と信頼性を IP と TCP の形で分離したプロトコルスイートである。この分離により、複雑なトランスポート機能はエンドシステムだけで行えるようになった。このような設計思想は End-to-End Principle と呼ばれる。</p><h1 id=tcp>TCP</h1><p>TCP は コネクション指向であり、Go-back-N ARQ を基本とする輻輳制御プロトコルである。
コネクション指向通信とは、実際にデータをやりとりする前に、通信を確立する通信である。TCP では、three-way handshake を用いてコネクションを確立する。
シーケンス番号と確認応答番号やチェックサムを使った高品質な伝送のための再送制御は、データ通信網においては必須の機能と言え、TCP の本質的な部分ではない。TCP の本質的に重要な役割は、<strong>フロー制御</strong>と<strong>輻輳制御</strong>である。
TCP は、<strong>ウィンドウ</strong>によって上記2つを同時に達成している。</p><h2 id=フロー制御>フロー制御</h2><p>フロー制御は、受信側が処理できるペースで送信するエンドツーエンドのメカニズムである。TCP では、スライディングウィンドウでフロー制御を行う。受信側は送信側に受信ウィンドウサイズ (rwnd) を広告する。通信中は動的にウィンドウサイズを変更できる。</p><h2 id=輻輳制御>輻輳制御</h2><p>IP では、データをパケットの単位で交換する。パケット網での輻輳とは、ネットワーク上のパケット量が許容値を超えて、パケットが正常に配送されなかったり、遅延する現象のことである。パケット交換は、実際にはルータが行う。ルータはパケット処理のために多少のバッファがある。パケット過多の場合、バッファにはパケットが累積し、これが遅延となる。また、バッファが一杯の場合、パケットは破棄される。慢性的に輻輳し、エンド間ではパケットを再送する処理をした場合、更に輻輳が悪化する。この現象は輻輳崩壊と呼ばれる。輻輳を防ぐ、または回避するためのメカニズムが輻輳制御である。TCP ではパケットロスを輻輳検知に利用して、輻輳を回避する制御を行う。</p><h3 id=スロースタート>スロースタート</h3><p>フロー制御だけでは、ネットワーク自体の許容量を制御できず、輻輳が起こる。通信中に、ネットワークの利用可能な帯域幅に調整する必要がある。利用可能な通信容量を推測する唯一の方法は、実際に送受信をすることである。
TCP 接続毎に輻輳ウィンドウサイズ (cwnd) を初期化し、控えめな値からスタートする。</p><h3 id=輻輳制御アルゴリズム>輻輳制御アルゴリズム</h3><p>スロースタート後は、ACK が帰ってくるたびにウィンドウサイズを大きくする。実際に使用されるウィンドウサイズは、min(rwnd, cwnd) である。TCP では、ウインドウサイズを指数的に増加させる。どこかのタイミングでパケットロスが発生した場合、cwnd を引き下げることで、パケットロスを最小化させる。このときに動作するウインドウサイズを調整するアルゴリズムはいくつかあり、オリジナルは TCP Reno、Linux のデフォルトは TCP CUBIC である。</p><h1 id=tcp-のパフォーマンス>TCP のパフォーマンス</h1><p>主に Web ブラウジングのために考慮すべきパフォーマンス事項と Linux での設定。</p><h2 id=ウインドウサイズ>ウインドウサイズ</h2><h3 id=スロースタート-initcwnd-の緩和>スロースタート (initcwnd) の緩和</h3><ul><li>RFC 793: 1 セグメント (MSS; Ethernet だと 1500 Byte)</li><li>RFC 2581: 最高 4 セグメント</li><li>RFC 6928: 最高 10 セグメント (<a href=https://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/>Linux 3.0.0</a>)</li></ul><h3 id=ウインドウスケーリング-rfc-1323>ウインドウスケーリング (RFC 1323)</h3><p>TCP の最初の仕様では、ウインドウサイズは 2^16 = 65535 Byte が最大だった。
ウインドウスケーリングオプションにより、1 GB まで引き上げることが可能になった。</p><p><code>sysctl net.ipv4.tcp_window_scaling</code></p><h4 id=帯域幅遅延積>帯域幅遅延積</h4><p>ウインドウサイズを考慮しない場合、最初に送信した TCP セグメントの ACK が帰ってくるまでに別の TCP セグメントを詰め込められるだけ詰め込んだ場合、ACK 待ちの時間が発生せず、理論上の最大スループットとなる。このスループットはリンク容量 [bps] と RTT [s] の積で表され、帯域幅遅延積と呼ばれる。すなわち、帯域幅遅延積よりも小さいウインドウサイズの場合、データフローは途切れることになり、パフォーマンスは悪化する。</p><h2 id=tcp-fast-open-rfc-7413>TCP Fast Open (RFC 7413)</h2><p>Three-way handshake は、TCP で必ず存在し、短い通信が大量に必要になることがある Web ブラウジングにおいてはレイテンシの大きな要因になる。TCP Fast Open は、Fast Open Cookie を用いてクライアントを識別し、2回目以降は SYN にリクエスト・レスポンスを同梱する方式である。</p><p><code>sysctl net.ipv4.tcp_fastopen</code></p><h2 id=slow-start-restart>Slow Start Restart</h2><p>Slow Start Restart は、アイドル状態のコネクションの輻輳ウインドウサイズをリセットするメカニズム。HTTP の Keep-Alive などに悪影響なので無効にした方が良い</p><p><code>sysctl net.ipv4.tcp_slow_start_after_idle</code></p><h2 id=tcp-selective-acknowledgement>TCP Selective Acknowledgement</h2><p>TCP は元々 Go-Back-N ARQ をベースとしたプロトコルであるが、ARQ の動作を Selective Repeat に変更できる。Selective Repeat は Go-Back-N と似ているが、途中でパケットが失われた場合、送信側は失われたパケットだけ再送する。</p><p><code>sysctl net.ipv4.tcp_sack</code></p><h1 id=参考文献>参考文献</h1><ul><li><a href=https://www.oreilly.co.jp/books/9784873116761/>ハイパフォーマンスブラウザネットワーキング</a></li><li><a href=https://access.redhat.com/sites/default/files/attachments/20150325_network_performance_tuning.pdf>Red Hat Enterprise Linux Network Performance Tuning Guide</a></li></ul><br><p class=back-to-posts><a href=https://itkq.jp/blog/>Back to posts</a></p></div><br><div class=disqus><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"itkq-jp"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-71205730-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js></script><script type=text/javascript>hljs.initHighlightingOnLoad();</script></body></html>
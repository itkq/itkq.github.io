<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content=itkq><meta name=description content="メモです．
3章 式の条件分岐  SQLのパフォーマンスは，テーブルスキャンによる I/O を減らすことが重要． 手続き的な WHERE, UNION による条件分岐，テーブルフルスキャンが複数回行われる．同テーブル内では，SELECT 句で CASE WHEN で条件分岐させるとクエリの可読性，実行計画共に良くなることあるので，考えなしに UNION を使うのは危険． ただし，インデックスが使える場合は，「UNION による複数回のインデックススキャン」と「OR または IN による1回のフルスキャン」の勝負になり，UNION の方が速い場合もある．  4章 集約とカット GROUP BY には「集約」と「カット」の機能がある．「カット」とはパーティションをつくること．ウィンドウ関数の PARTITION BY はカットのための機能．
 最近のオプティマイザは，GROUP BY による集約は，指定された列のハッシュ値によってグループ化している．古典的なソートより高速である． GROUP BY では，ハッシュかソートいずれの場合でも，メモリを多く使用するため，ワーキングメモリを使い切ってしまうこと（TEMP落ち）に注意． SELECT 句で指定するキーと，GROUP BY 句で指定するキーを同じくすることでカットできる．  5章 手続きSQL SQL実行のオーバーヘッド：
 SQL文のネットワーク伝送
 データベースへの接続
 SQL文のパース
 SQL文の実行計画生成および評価
 結果セットのネットワーク伝送
  1と5は，同一ネットワーク上であればほぼ無視できる．2はコネクションプールで対応できる．このうち，3と4が支配的である． ある処理を達成するために，逐次的な「軽いSQL」によるロジックと，一度の「重いSQL」によるロジックがある．
軽いSQLによる問題：
 DBのストレージは普通RAIDで構成され，I/O負荷を分散できるが，軽いSQLは，並列分散による恩恵が受けづらい
 DBは，重いSQLを高速化するように進化する．軽いSQLはそもそもチューニングポテンシャルがない
  一方で軽いSQLの利点："><meta name=google-site-verification content=AyWEWMfqdOijgoPW5yMy188xoQqY46L6pFXyd3Jizyc><meta property=og:title content="SQL実践入門 読んだ"><meta property=og:description content="メモです．
3章 式の条件分岐  SQLのパフォーマンスは，テーブルスキャンによる I/O を減らすことが重要． 手続き的な WHERE, UNION による条件分岐，テーブルフルスキャンが複数回行われる．同テーブル内では，SELECT 句で CASE WHEN で条件分岐させるとクエリの可読性，実行計画共に良くなることあるので，考えなしに UNION を使うのは危険． ただし，インデックスが使える場合は，「UNION による複数回のインデックススキャン」と「OR または IN による1回のフルスキャン」の勝負になり，UNION の方が速い場合もある．  4章 集約とカット GROUP BY には「集約」と「カット」の機能がある．「カット」とはパーティションをつくること．ウィンドウ関数の PARTITION BY はカットのための機能．
 最近のオプティマイザは，GROUP BY による集約は，指定された列のハッシュ値によってグループ化している．古典的なソートより高速である． GROUP BY では，ハッシュかソートいずれの場合でも，メモリを多く使用するため，ワーキングメモリを使い切ってしまうこと（TEMP落ち）に注意． SELECT 句で指定するキーと，GROUP BY 句で指定するキーを同じくすることでカットできる．  5章 手続きSQL SQL実行のオーバーヘッド：
 SQL文のネットワーク伝送
 データベースへの接続
 SQL文のパース
 SQL文の実行計画生成および評価
 結果セットのネットワーク伝送
  1と5は，同一ネットワーク上であればほぼ無視できる．2はコネクションプールで対応できる．このうち，3と4が支配的である． ある処理を達成するために，逐次的な「軽いSQL」によるロジックと，一度の「重いSQL」によるロジックがある．
軽いSQLによる問題：
 DBのストレージは普通RAIDで構成され，I/O負荷を分散できるが，軽いSQLは，並列分散による恩恵が受けづらい
 DBは，重いSQLを高速化するように進化する．軽いSQLはそもそもチューニングポテンシャルがない
  一方で軽いSQLの利点："><meta property=og:type content=article><meta property=og:url content=https://itkq.jp/blog/2017/03/15/sql-practice/><meta property=article:published_time content=2017-03-15T19:19:27&#43;09:00><meta property=article:modified_time content=2017-03-15T19:19:27&#43;09:00><title>SQL実践入門 読んだ</title><link rel=canonical href=https://itkq.jp/blog/2017/03/15/sql-practice/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/github.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500"><link rel=stylesheet href="https://itkq.jp/css/reset.css?t=2020-06-20%2014%3a17%3a11.066864441%20%2b0900%20JST%20m%3d%2b0.100218827"><link rel=stylesheet href="https://itkq.jp/css/pygments.css?t=2020-06-20%2014%3a17%3a11.066864441%20%2b0900%20JST%20m%3d%2b0.100218827"><link rel=stylesheet href="https://itkq.jp/css/main.css?t=2020-06-20%2014%3a17%3a11.066864441%20%2b0900%20JST%20m%3d%2b0.100218827"><link rel=stylesheet href="https://itkq.jp/css/override.css?t=2020-06-20%2014%3a17%3a11.066864441%20%2b0900%20JST%20m%3d%2b0.100218827"><link rel="shortcut icon" href=https://itkq.jp/img/leaf.ico></head><body lang=ja><section class=header><div class=container><a href=https://itkq.jp/><img class=avatar src=https://itkq.jp/img/profile.png srcset="https://itkq.jp/img/profile.png 1x"></a><div class=content><a href=https://itkq.jp/><div class=name>itkq</div></a><nav><ul><li class=nav-blog><a href=https://itkq.jp/blog/><span>Blog</span></a></li><li class=nav-about><a href=https://itkq.jp/about/><span>About</span></a></li></ul></nav></div></div></section><section class=icons><div class=container><div class=content><a href=https://github.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/github.svg alt=github></a>
<a href=https://twitter.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/twitter.svg alt=twitter></a>
<a href=//linkedin.com/in/takuya-kosugiyama-107402195/ target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/linkedin.svg alt=linkedin></a>
<a href=mailto:re@itkq.jp><img class=icon src=https://itkq.jp/img/email.svg alt=email></a></div></div></section><section class="main post non-narrow zero-top-spacing"><div class=container><div class=content><div class=front-matter><div class=title-container><div class=page-heading>SQL実践入門 読んだ</div><div class=initials><a href=https://itkq.jp/>ad</a></div></div><div class=meta><div class=date title="Wed Mar 15 2017 19:19:27 JST">Mar 15, 2017</div></div></div><div class=markdown><p>メモです．</p><h1 id=3章-式の条件分岐>3章 式の条件分岐</h1><ul><li>SQLのパフォーマンスは，テーブルスキャンによる I/O を減らすことが重要．</li><li>手続き的な <code>WHERE</code>, <code>UNION</code> による条件分岐，テーブルフルスキャンが複数回行われる．<strong>同テーブル内</strong>では，<code>SELECT</code> 句で <code>CASE WHEN</code> で条件分岐させるとクエリの可読性，実行計画共に良くなることあるので，考えなしに <code>UNION</code> を使うのは危険．</li><li>ただし，インデックスが使える場合は，「<code>UNION</code> による複数回のインデックススキャン」と「<code>OR</code> または <code>IN</code> による1回のフルスキャン」の勝負になり，<code>UNION</code> の方が速い場合もある．</li></ul><h1 id=4章-集約とカット>4章 集約とカット</h1><p><code>GROUP BY</code> には「集約」と「カット」の機能がある．「カット」とはパーティションをつくること．ウィンドウ関数の <code>PARTITION BY</code> はカットのための機能．</p><ul><li>最近のオプティマイザは，<code>GROUP BY</code> による集約は，指定された列のハッシュ値によってグループ化している．古典的なソートより高速である．</li><li><code>GROUP BY</code> では，ハッシュかソートいずれの場合でも，メモリを多く使用するため，ワーキングメモリを使い切ってしまうこと（TEMP落ち）に注意．</li><li><code>SELECT</code> 句で指定するキーと，<code>GROUP BY</code> 句で指定するキーを同じくすることでカットできる．</li></ul><h1 id=5章-手続きsql>5章 手続きSQL</h1><p>SQL実行のオーバーヘッド：</p><ol><li>SQL文のネットワーク伝送<br></li><li>データベースへの接続<br></li><li><em>SQL文のパース</em><br></li><li><em>SQL文の実行計画生成および評価</em><br></li><li>結果セットのネットワーク伝送<br></li></ol><p>1と5は，同一ネットワーク上であればほぼ無視できる．2はコネクションプールで対応できる．このうち，3と4が支配的である．
ある処理を達成するために，逐次的な「軽いSQL」によるロジックと，一度の「重いSQL」によるロジックがある．</p><p>軽いSQLによる問題：</p><ul><li>DBのストレージは普通RAIDで構成され，I/O負荷を分散できるが，軽いSQLは，並列分散による恩恵が受けづらい<br></li><li>DBは，重いSQLを高速化するように進化する．軽いSQLは<em>そもそもチューニングポテンシャルがない</em><br></li></ul><p>一方で軽いSQLの利点：</p><ul><li>実行計画が安定し，処理時間が相対的に見積もりやすい<br></li><li>トランザクション粒度を調整できる</li></ul><p>一撃でループ処理をするSQLの書き方：</p><ul><li>ウィンドウ関数と <code>CASE</code> 式を使う<br><ul><li><code>CASE</code> 式の <code>WHEN</code> は短絡評価<br></li></ul></li><li>隣接リスト的なデータ構造に対しては，Recurvie Union による再帰クエリが有効<br></li></ul><h1 id=6章-結合>6章 結合</h1><p>結合は3種類：</p><ul><li>cross join：2つのテーブルの直積<br></li><li>inner join：cross join の部分集合<br></li><li>outer join：cross join に含まれない (NULL) 行を含む</li></ul><p>オプティマイザが選択可能な結合アルゴリズムは3種類．ただし，<strong>MySQL は Nested Loops しか使えない</strong>．結合は実行計画が変動しやすいため，そもそも結合を回避することが1つの戦略である．</p><h2 id=nested-loops>Nested Loops</h2><p>二重ループによる結合．外側のループに対応するものを <strong>driving table (駆動表)</strong> または <strong>outer table (外部表)</strong> と呼び，もう一方を <strong>inner table (内部表)</strong> と呼ぶ．</p><ul><li>「小さな駆動表」＋「内部表のインデックススキャン」で高速<br></li><li>メモリ・ディスク使用量が少ない<br></li><li>非等値結合可能<br></li><li>大規模テーブル同士の結合には不向き<br><ul><li>Hash, Sort Merge のいずれかを使う<br><br></li></ul></li></ul><h2 id=hash>Hash</h2><p>まず小さいテーブルの結合キーのハッシュテーブルをつくる．次に，大きなテーブルに対して結合キーのハッシュ値とハッシュテーブルのマッチングを行う．</p><ul><li>等値結合不可能<br></li><li>メモリ消費量が大きい</li></ul><h2 id=sort-merge>Sort Merge</h2><p>二つのテーブルを結合キーでソートし，マッチングを行う．</p><ul><li>不等号結合可能<br></li><li>ソート済みでない限り効率的ではない</li></ul><p><code>A INNER JOIN B INNER JOIN C</code> のような「三角結合」の場合，オプティマイザによっては意図しないBとCのクロス結合が行われる場合がある．明示的に冗長なBとCの結合条件を加えることで，これを回避できる．</p><h1 id=7章-サブクエリ>7章 サブクエリ</h1><ul><li><p>サブクエリの位置</p><ul><li>テーブル：永続的，データを保持する<br></li><li>ビュー：永続的，データは保持しない（アクセスの度に <code>SELECT</code> 文が発行）<br></li><li>サブクエリ：非永続的，データは保持しない（SQL文の度に <code>SELECT</code> 文が発行），スコープ限定</li></ul></li><li><p>サブクエリは使いやすいが，計算コストが上乗せされ，最適化がされず性能面で問題がある．</p></li><li><p>サブクエリと結合はウインドウ関数で代替する</p></li><li><p>結合と集約の操作が必要な場合は，先に集約することで行数を減らせる</p></li></ul><h1 id=8-9-10章>8, 9, 10章</h1><p>必要になったらまた読む</p><br><p class=back-to-posts><a href=https://itkq.jp/blog/>Back to posts</a></p></div><br><div class=disqus><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"itkq-jp"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-71205730-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js></script><script type=text/javascript>hljs.initHighlightingOnLoad();</script></body></html>
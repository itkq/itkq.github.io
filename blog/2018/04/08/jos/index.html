<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content=itkq><meta name=description content="修論を書き終えたあたりから、春休みに何をするか考えていた。4月からソフトウェアエンジニアとして働き、主にインフラの仕事をする予定だったので、まとまった時間が必要かつ将来役に立ちそうなことを考えた。
ちょうどその頃に turingcomplete.fm を聞いて、OS を学びたい気持ちになった。そうして始めたのが MIT の 6.828: Operating System Engineering の授業である。JOS という xv6 ライクな小さい x86 OS のスケルトンが用意されており、必要な部分を実装していくことが課題である。シェルの動作までを完成させた後、最終課題としてパケット送受信かオリジナル機能を実装して終了ということになっている。
選択した理由 30日OS本も検討していて図書館で借りた。書くべきコードはインターネットですべて入手可能だったため、本を眺めてなんとなく分かった気持ちになって終わる予想ができた。とにかく手を動かしたほうが絶対いいという確信があった。一方 JOS は、OS の動作原理を学ぶものなので、ハードウェアに近い部分の実装は与えられ、Operating Systems Engieering の文脈で重要だとされる部分に集中でき、かつ手を動かす必要がある。まさに自分の求めている題材だと感じた。課題にはテストケースが付属しており、実装が正しいかどうかはある程度確認できることも良い。OS を自作したいというより OS を学びたい気持ちが強かった。
目的 必要が生じた時に Linux のソースコードの該当部分を探して、その内容を理解できるように OS の知識を体系的に得ること
学べたこと 3&frasl;31 までに Lab 5 までを終えた時点で挙げた (粒度は雑)。作業ログ
x86 OS Lab 1: Booting a PC  物理アドレス空間 real-mode, protected-mode kernel 起動までの流れ  CPU が起動するとまず BIOS (0xffff0) に jump BIOS は boot sector を (0x7c00 ~ 0x7cff) に読み込み、32-bit protected-mode にスイッチして 0x7c00 に jump して boot loader が起動 kernel を 1 page 分読み込み ELF header を検証し、program segment をそれぞれ読み込む ELF header に埋め込まれた entry point をコールして kernel が起動   Lab 2: Memory Management  物理ページ MMU  Virtual address, Linear address, Physical address Page Directory, Page Table  Page Table 管理  ページと対応する構造体で参照を管理する Page Directory Entry =&gt; Page Table Entry =&gt; PageInfo =&gt; 物理ページ  カーネルアドレス空間 (レイアウトは与えられている)  Lab 3: User Environments  User-mode environment, または “process“ の状態表現 プロセスの仮想アドレス空間のセットアップ システムコールの割り込みハンドリング  Interrupt Descriptor Table (IDT) セグメント毎の privilege level trapframe の表現方法  page fault ハンドリング  メモリ保護: アドレス範囲と PTE 属性   Lab 4: Preemptive Multitasking  Symmetric Multiprocessing (SMP): 全プロセッサが等価にリソースを触れる  Bootstrap Processor (BSP) が他のプロセッサ (Application Processors; APs) を起こす  それぞれのプロセッサが割り込みコントローラ (LAPIC) を持ち、LAPIC で各プロセッサを判断する APs は real-mode で起動するため初期化が必要 CPU 毎の kernel stack 領域 big kernel lock (spin lock)  spin lock の実体はアトミックに値を交換する命令 xchg  素朴な Round-Robin Scheduling の実体 (プロセスの状態遷移) Unix-like fork() のためのシステムコール、fork の中身  ページマッピングのコピーとCOW属性、User-level page fault handling による Copy-on-Write  再帰的に page fault できるような exception stack を使った仕組み Hardware clock interrupts を使った preemptive multitasking Inter-Process communication (IPC) のメッセージを送受信するシステムコールによる実装  Lab 5: File System, Spawn and Shell  セクタとブロック メタ情報を格納する superblocks ファイルに対応するブロックの表現: 直接参照と間接参照によって大容量のファイルも扱うことができる JOS ではカーネルにディスクアクセス機能を実装していないので、ユーザーレベルの environment (プロセス) として実装する  ディスク割り込みではなくポーリングを使う Programmed I/O (PIO) ベースのアクセス  仮想アドレスへのファイルマッピングはデマンドページングによるブロックキャッシュ ビットマップでブロックの使用を表現 サーバークライアントモデルのファイルシステムインターフェース “Exokernel” 的な spawn: open して elf を読み込み、fork する。child の trapframe (eip や privilege level ) を設定する file descriptor table のアドレス領域は、PTE を共有することで file descriptor を共有する シェルプロセスの実装 I/O redirection, pipe の実装  プログラミング技術  C言語のポインタ: スタックやメモリを触った途端に理解できる インラインアセンブラ アセンブリレベルの calling convention  学ばなかった (知らなくても課題は解ける) こと  ELF フォーマットの詳細 必要以外の x86 instructions QEMU CMOS RAM hardware  詳しく知りたくなったこと  Linux のプロセスとスレッドの実装 Linux プロセススケジューリングのアルゴリズム Linux のファイルシステム  パーティションの中身  x86_64 との差分 UNIX-style の exec  感想 実際に手を動かしていくと、コードとの対応も取れ理解が進むように思えた。学びたい気持ちはあるけど題材がない場合、このような教材を使って無理やり学ぶという選択肢もアリだなと思った。"><meta name=google-site-verification content=AyWEWMfqdOijgoPW5yMy188xoQqY46L6pFXyd3Jizyc><meta property=og:title content="OS ほんのちょっとだけ分かるための JOS"><meta property=og:description content="修論を書き終えたあたりから、春休みに何をするか考えていた。4月からソフトウェアエンジニアとして働き、主にインフラの仕事をする予定だったので、まとまった時間が必要かつ将来役に立ちそうなことを考えた。
ちょうどその頃に turingcomplete.fm を聞いて、OS を学びたい気持ちになった。そうして始めたのが MIT の 6.828: Operating System Engineering の授業である。JOS という xv6 ライクな小さい x86 OS のスケルトンが用意されており、必要な部分を実装していくことが課題である。シェルの動作までを完成させた後、最終課題としてパケット送受信かオリジナル機能を実装して終了ということになっている。
選択した理由 30日OS本も検討していて図書館で借りた。書くべきコードはインターネットですべて入手可能だったため、本を眺めてなんとなく分かった気持ちになって終わる予想ができた。とにかく手を動かしたほうが絶対いいという確信があった。一方 JOS は、OS の動作原理を学ぶものなので、ハードウェアに近い部分の実装は与えられ、Operating Systems Engieering の文脈で重要だとされる部分に集中でき、かつ手を動かす必要がある。まさに自分の求めている題材だと感じた。課題にはテストケースが付属しており、実装が正しいかどうかはある程度確認できることも良い。OS を自作したいというより OS を学びたい気持ちが強かった。
目的 必要が生じた時に Linux のソースコードの該当部分を探して、その内容を理解できるように OS の知識を体系的に得ること
学べたこと 3&frasl;31 までに Lab 5 までを終えた時点で挙げた (粒度は雑)。作業ログ
x86 OS Lab 1: Booting a PC  物理アドレス空間 real-mode, protected-mode kernel 起動までの流れ  CPU が起動するとまず BIOS (0xffff0) に jump BIOS は boot sector を (0x7c00 ~ 0x7cff) に読み込み、32-bit protected-mode にスイッチして 0x7c00 に jump して boot loader が起動 kernel を 1 page 分読み込み ELF header を検証し、program segment をそれぞれ読み込む ELF header に埋め込まれた entry point をコールして kernel が起動   Lab 2: Memory Management  物理ページ MMU  Virtual address, Linear address, Physical address Page Directory, Page Table  Page Table 管理  ページと対応する構造体で参照を管理する Page Directory Entry =&gt; Page Table Entry =&gt; PageInfo =&gt; 物理ページ  カーネルアドレス空間 (レイアウトは与えられている)  Lab 3: User Environments  User-mode environment, または “process“ の状態表現 プロセスの仮想アドレス空間のセットアップ システムコールの割り込みハンドリング  Interrupt Descriptor Table (IDT) セグメント毎の privilege level trapframe の表現方法  page fault ハンドリング  メモリ保護: アドレス範囲と PTE 属性   Lab 4: Preemptive Multitasking  Symmetric Multiprocessing (SMP): 全プロセッサが等価にリソースを触れる  Bootstrap Processor (BSP) が他のプロセッサ (Application Processors; APs) を起こす  それぞれのプロセッサが割り込みコントローラ (LAPIC) を持ち、LAPIC で各プロセッサを判断する APs は real-mode で起動するため初期化が必要 CPU 毎の kernel stack 領域 big kernel lock (spin lock)  spin lock の実体はアトミックに値を交換する命令 xchg  素朴な Round-Robin Scheduling の実体 (プロセスの状態遷移) Unix-like fork() のためのシステムコール、fork の中身  ページマッピングのコピーとCOW属性、User-level page fault handling による Copy-on-Write  再帰的に page fault できるような exception stack を使った仕組み Hardware clock interrupts を使った preemptive multitasking Inter-Process communication (IPC) のメッセージを送受信するシステムコールによる実装  Lab 5: File System, Spawn and Shell  セクタとブロック メタ情報を格納する superblocks ファイルに対応するブロックの表現: 直接参照と間接参照によって大容量のファイルも扱うことができる JOS ではカーネルにディスクアクセス機能を実装していないので、ユーザーレベルの environment (プロセス) として実装する  ディスク割り込みではなくポーリングを使う Programmed I/O (PIO) ベースのアクセス  仮想アドレスへのファイルマッピングはデマンドページングによるブロックキャッシュ ビットマップでブロックの使用を表現 サーバークライアントモデルのファイルシステムインターフェース “Exokernel” 的な spawn: open して elf を読み込み、fork する。child の trapframe (eip や privilege level ) を設定する file descriptor table のアドレス領域は、PTE を共有することで file descriptor を共有する シェルプロセスの実装 I/O redirection, pipe の実装  プログラミング技術  C言語のポインタ: スタックやメモリを触った途端に理解できる インラインアセンブラ アセンブリレベルの calling convention  学ばなかった (知らなくても課題は解ける) こと  ELF フォーマットの詳細 必要以外の x86 instructions QEMU CMOS RAM hardware  詳しく知りたくなったこと  Linux のプロセスとスレッドの実装 Linux プロセススケジューリングのアルゴリズム Linux のファイルシステム  パーティションの中身  x86_64 との差分 UNIX-style の exec  感想 実際に手を動かしていくと、コードとの対応も取れ理解が進むように思えた。学びたい気持ちはあるけど題材がない場合、このような教材を使って無理やり学ぶという選択肢もアリだなと思った。"><meta property=og:type content=article><meta property=og:url content=https://itkq.jp/blog/2018/04/08/jos/><meta property=article:published_time content=2018-04-08T18:27:42&#43;09:00><meta property=article:modified_time content=2018-04-08T18:27:42&#43;09:00><title>OS ほんのちょっとだけ分かるための JOS</title><link rel=canonical href=https://itkq.jp/blog/2018/04/08/jos/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/github.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500"><link rel=stylesheet href="https://itkq.jp/css/reset.css?t=2020-06-20%2014%3a17%3a11.038795616%20%2b0900%20JST%20m%3d%2b0.072150002"><link rel=stylesheet href="https://itkq.jp/css/pygments.css?t=2020-06-20%2014%3a17%3a11.038795616%20%2b0900%20JST%20m%3d%2b0.072150002"><link rel=stylesheet href="https://itkq.jp/css/main.css?t=2020-06-20%2014%3a17%3a11.038795616%20%2b0900%20JST%20m%3d%2b0.072150002"><link rel=stylesheet href="https://itkq.jp/css/override.css?t=2020-06-20%2014%3a17%3a11.038795616%20%2b0900%20JST%20m%3d%2b0.072150002"><link rel="shortcut icon" href=https://itkq.jp/img/leaf.ico></head><body lang=ja><section class=header><div class=container><a href=https://itkq.jp/><img class=avatar src=https://itkq.jp/img/profile.png srcset="https://itkq.jp/img/profile.png 1x"></a><div class=content><a href=https://itkq.jp/><div class=name>itkq</div></a><nav><ul><li class=nav-blog><a href=https://itkq.jp/blog/><span>Blog</span></a></li><li class=nav-about><a href=https://itkq.jp/about/><span>About</span></a></li></ul></nav></div></div></section><section class=icons><div class=container><div class=content><a href=https://github.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/github.svg alt=github></a>
<a href=https://twitter.com/itkq target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/twitter.svg alt=twitter></a>
<a href=//linkedin.com/in/takuya-kosugiyama-107402195/ target=_blank rel=noopener><img class=icon src=https://itkq.jp/img/linkedin.svg alt=linkedin></a>
<a href=mailto:re@itkq.jp><img class=icon src=https://itkq.jp/img/email.svg alt=email></a></div></div></section><section class="main post non-narrow zero-top-spacing"><div class=container><div class=content><div class=front-matter><div class=title-container><div class=page-heading>OS ほんのちょっとだけ分かるための JOS</div><div class=initials><a href=https://itkq.jp/>ad</a></div></div><div class=meta><div class=date title="Sun Apr 8 2018 18:27:42 JST">Apr 8, 2018</div></div></div><div class=markdown><p>修論を書き終えたあたりから、春休みに何をするか考えていた。4月からソフトウェアエンジニアとして働き、主にインフラの仕事をする予定だったので、まとまった時間が必要かつ将来役に立ちそうなことを考えた。</p><p>ちょうどその頃に turingcomplete.fm を聞いて、OS を学びたい気持ちになった。そうして始めたのが MIT の <a href=https://pdos.csail.mit.edu/6.828/2017/schedule.html>6.828: Operating System Engineering</a> の授業である。JOS という xv6 ライクな小さい x86 OS のスケルトンが用意されており、必要な部分を実装していくことが課題である。シェルの動作までを完成させた後、最終課題としてパケット送受信かオリジナル機能を実装して終了ということになっている。</p><h2 id=選択した理由>選択した理由</h2><p>30日OS本も検討していて図書館で借りた。書くべきコードはインターネットですべて入手可能だったため、本を眺めてなんとなく分かった気持ちになって終わる予想ができた。とにかく手を動かしたほうが絶対いいという確信があった。一方 JOS は、OS の動作原理を学ぶものなので、ハードウェアに近い部分の実装は与えられ、Operating Systems Engieering の文脈で重要だとされる部分に集中でき、かつ手を動かす必要がある。まさに自分の求めている題材だと感じた。課題にはテストケースが付属しており、実装が正しいかどうかはある程度確認できることも良い。OS を自作したいというより OS を学びたい気持ちが強かった。</p><h2 id=目的>目的</h2><p>必要が生じた時に Linux のソースコードの該当部分を探して、その内容を理解できるように OS の知識を体系的に得ること</p><h2 id=学べたこと>学べたこと</h2><p><sup>3</sup>&frasl;<sub>31</sub> までに Lab 5 までを終えた時点で挙げた (粒度は雑)。<a href=http://itkq.hatenablog.com/archive/category/JOS>作業ログ</a></p><h3 id=x86-os>x86 OS</h3><h4 id=lab-1-booting-a-pc>Lab 1: Booting a PC</h4><ul><li>物理アドレス空間</li><li>real-mode, protected-mode</li><li>kernel 起動までの流れ<ul><li>CPU が起動するとまず BIOS (0xffff0) に jump</li><li>BIOS は boot sector を (0x7c00 ~ 0x7cff) に読み込み、32-bit protected-mode にスイッチして 0x7c00 に jump して boot loader が起動</li><li>kernel を 1 page 分読み込み ELF header を検証し、program segment をそれぞれ読み込む</li><li>ELF header に埋め込まれた entry point をコールして kernel が起動</li></ul></li></ul><h4 id=lab-2-memory-management>Lab 2: Memory Management</h4><ul><li>物理ページ</li><li>MMU<ul><li>Virtual address, Linear address, Physical address</li><li>Page Directory, Page Table</li></ul></li><li>Page Table 管理<ul><li>ページと対応する構造体で参照を管理する</li><li>Page Directory Entry =&gt; Page Table Entry =&gt; PageInfo =&gt; 物理ページ</li></ul></li><li>カーネルアドレス空間 (レイアウトは与えられている)</li></ul><h4 id=lab-3-user-environments>Lab 3: User Environments</h4><ul><li>User-mode environment, または “process“ の状態表現</li><li>プロセスの仮想アドレス空間のセットアップ</li><li>システムコールの割り込みハンドリング<ul><li>Interrupt Descriptor Table (IDT)</li><li>セグメント毎の privilege level</li><li>trapframe の表現方法</li></ul></li><li>page fault ハンドリング<ul><li>メモリ保護: アドレス範囲と PTE 属性</li></ul></li></ul><h4 id=lab-4-preemptive-multitasking>Lab 4: Preemptive Multitasking</h4><ul><li>Symmetric Multiprocessing (SMP): 全プロセッサが等価にリソースを触れる<ul><li>Bootstrap Processor (BSP) が他のプロセッサ (Application Processors; APs) を起こす</li></ul></li><li>それぞれのプロセッサが割り込みコントローラ (LAPIC) を持ち、LAPIC で各プロセッサを判断する</li><li>APs は real-mode で起動するため初期化が必要</li><li>CPU 毎の kernel stack 領域</li><li>big kernel lock (spin lock)<ul><li>spin lock の実体はアトミックに値を交換する命令 <code>xchg</code></li></ul></li><li>素朴な Round-Robin Scheduling の実体 (プロセスの状態遷移)</li><li>Unix-like fork() のためのシステムコール、fork の中身<ul><li>ページマッピングのコピーと<code>COW</code>属性、User-level page fault handling による Copy-on-Write</li></ul></li><li>再帰的に page fault できるような exception stack を使った仕組み</li><li>Hardware clock interrupts を使った preemptive multitasking</li><li>Inter-Process communication (IPC) のメッセージを送受信するシステムコールによる実装</li></ul><h4 id=lab-5-file-system-spawn-and-shell>Lab 5: File System, Spawn and Shell</h4><ul><li>セクタとブロック</li><li>メタ情報を格納する superblocks</li><li>ファイルに対応するブロックの表現: 直接参照と間接参照によって大容量のファイルも扱うことができる</li><li>JOS ではカーネルにディスクアクセス機能を実装していないので、ユーザーレベルの environment (プロセス) として実装する<ul><li>ディスク割り込みではなくポーリングを使う Programmed I/O (PIO) ベースのアクセス</li></ul></li><li>仮想アドレスへのファイルマッピングはデマンドページングによるブロックキャッシュ</li><li>ビットマップでブロックの使用を表現</li><li>サーバークライアントモデルのファイルシステムインターフェース</li><li>“Exokernel” 的な spawn: open して elf を読み込み、fork する。child の trapframe (eip や privilege level ) を設定する</li><li>file descriptor table のアドレス領域は、PTE を共有することで file descriptor を共有する</li><li>シェルプロセスの実装</li><li>I/O redirection, pipe の実装</li></ul><h3 id=プログラミング技術>プログラミング技術</h3><ul><li>C言語のポインタ: スタックやメモリを触った途端に理解できる</li><li>インラインアセンブラ</li><li>アセンブリレベルの calling convention</li></ul><h2 id=学ばなかった-知らなくても課題は解ける-こと>学ばなかった (知らなくても課題は解ける) こと</h2><ul><li>ELF フォーマットの詳細</li><li>必要以外の x86 instructions</li><li>QEMU</li><li>CMOS RAM hardware</li></ul><h2 id=詳しく知りたくなったこと>詳しく知りたくなったこと</h2><ul><li>Linux のプロセスとスレッドの実装</li><li>Linux プロセススケジューリングのアルゴリズム</li><li>Linux のファイルシステム<ul><li>パーティションの中身</li></ul></li><li>x86_64 との差分</li><li>UNIX-style の exec</li></ul><h1 id=感想>感想</h1><p>実際に手を動かしていくと、コードとの対応も取れ理解が進むように思えた。学びたい気持ちはあるけど題材がない場合、このような教材を使って無理やり学ぶという選択肢もアリだなと思った。</p><p>特にメモリ管理が勉強になった。元々多少は知識があったが、取り組む前と後では理解度が全然違った気がする。
次は Linux のどこか、もしくは xv6 を読んでみようと思う。</p><br><p class=back-to-posts><a href=https://itkq.jp/blog/>Back to posts</a></p></div><br><div class=disqus><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"itkq-jp"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-71205730-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js></script><script type=text/javascript>hljs.initHighlightingOnLoad();</script></body></html>